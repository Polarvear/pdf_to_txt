<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PDF 텍스트 추출기 — 클라이언트 사이드(무DB)</title>
  <meta name="description" content="PDF 파일에서 텍스트만 추출해서 보여주고 .txt로 저장하는 100% 클라이언트 사이드 웹앱. DB/서버 불필요." />
  <style>
    /* ===== 기본 스타일 (라이트 전용, 다크모드 없음) ===== */
    :root {
      --bg: #ffffff;
      --fg: #111418;
      --muted: #5b6571;
      --brand: #2563eb;
      --border: #e5e7eb;
      --card: #f8fafc;
      --success: #16a34a;
      --danger: #dc2626;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, 
      Noto Sans KR, Apple SD Gothic Neo, Helvetica, Arial, sans-serif;
      color: var(--fg); background: var(--bg);
    }
    header { padding: 24px 16px; border-bottom: 1px solid var(--border); }
    header .wrap { max-width: 980px; margin: 0 auto; }
    h1 { margin: 0 0 6px; font-size: 24px; }
    .sub { color: var(--muted); font-size: 14px; }

    main { max-width: 980px; margin: 24px auto; padding: 0 16px 64px; }

    .u-flex { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; }

    .panel {
      background: var(--card); border: 1px solid var(--border);
      border-radius: 12px; padding: 16px; margin-bottom: 16px;
    }

    .dropzone {
      border: 2px dashed #cbd5e1; border-radius: 12px; background: #f1f5f9;
      padding: 24px; text-align: center; transition: 120ms ease-in-out;
    }
    .dropzone.dragover { border-color: var(--brand); background: #eef2ff; }

    .btn {
      appearance: none; border: 1px solid var(--border); background: #fff; color: var(--fg);
      border-radius: 10px; padding: 10px 14px; font-weight: 600; cursor: pointer;
      transition: transform .05s ease, box-shadow .2s ease, background .2s ease;
    }
    .btn:hover { box-shadow: 0 2px 8px rgba(0,0,0,.06); }
    .btn:active { transform: translateY(1px); }
    .btn.primary { background: var(--brand); color: #fff; border-color: var(--brand); }
    .btn.danger { background: #fff5f5; color: var(--danger); border-color: #fecaca; }
    .btn.ghost { background: transparent; }
    .btn.small { padding: 6px 10px; font-size: 13px; border-radius: 8px; }

    input[type="file"] { display: none; }
    label.file {
      display: inline-block; border: 1px dashed var(--border); background: #fff; color: var(--fg);
      border-radius: 10px; padding: 10px 14px; cursor: pointer; font-weight: 600;
    }

    .hint { color: var(--muted); font-size: 12px; }

    .grid { display: grid; grid-template-columns: 1fr; gap: 16px; }

    .card { background: #fff; border: 1px solid var(--border); border-radius: 12px; overflow: hidden; }
    .card .hd { display:flex; align-items:center; justify-content:space-between; padding:12px 14px; border-bottom:1px solid var(--border); }
    .card .bd { padding: 14px; }

    .meta { color: var(--muted); font-size: 13px; }
    .tag { display:inline-block; font-size:11px; padding:4px 8px; border:1px solid var(--border); border-radius:999px; background:#fafafa; color:#334155; }

    .progress { height: 8px; background: #eef2f7; border-radius: 999px; overflow: hidden; border: 1px solid var(--border); }
    .progress > span { display:block; height: 100%; width: 0%; background: var(--brand); transition: width .2s ease; }

    .row { display: grid; grid-template-columns: 1fr; gap: 10px; align-items: start; }
    .row.two { grid-template-columns: 1fr auto; }

    textarea.output {
      width: 100%; min-height: 220px; resize: vertical; font: 13px/1.5 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      color: #0f172a; background: #f8fafc; border: 1px solid var(--border); border-radius: 8px; padding: 10px;
      white-space: pre-wrap;
    }

    details { border: 1px solid var(--border); border-radius: 10px; background: #fff; }
    details + details { margin-top: 8px; }
    summary { cursor: pointer; padding: 10px 12px; font-weight: 700; }
    .pageText { padding: 10px 12px; border-top: 1px solid var(--border); background: #fafafa; font: 13px/1.5 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; white-space: pre-wrap; }

    .searchbar { display:flex; gap:8px; align-items:center; }
    .searchbar input { flex:1; padding:8px 10px; border:1px solid var(--border); border-radius:8px; }
    mark { background: #fff3cd; padding: 0 2px; border-radius: 3px; }

    .footer { color: var(--muted); font-size: 12px; padding: 10px 2px; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background:#f3f4f6; border:1px solid #e5e7eb; padding:2px 6px; border-radius:6px; }
  </style>
  <!-- pdf.js (CDN) - 버전은 필요시 교체 가능 -->
  <script>
    // CDN 기본 경로 (필요 시 원하는 버전으로 바꾸세요)
    const PDFJS_CDN_BASE = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.5.136";
  </script>
  <!-- pdf.js를 정적으로 로드해서 window.pdfjsLib가 보장되도록 함 (document.write 제거) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.5.136/pdf.min.js"></script>
</head>
<body>
  <header>
    <div class="wrap">
      <h1>PDF 텍스트 추출기</h1>
      <div class="sub">클라이언트 사이드에서만 동작 · DB/서버 불필요 · 업로드한 파일은 브라우저 메모리에서만 처리됩니다.</div>
    </div>
  </header>

  <main>
    <section class="panel">
      <div class="u-flex">
        <label class="file" for="fileInput">PDF 선택하기</label>
        <input id="fileInput" type="file" accept="application/pdf" multiple>
        <button id="btnClear" class="btn danger">초기화</button>
      </div>
      <div id="dropzone" class="dropzone" style="margin-top:12px">
        <strong>여기에 PDF를 드래그 앤 드롭</strong><br>
        <span class="hint">여러 파일 지원 · 스캔본(이미지 기반) PDF는 텍스트가 없을 수 있습니다</span>
      </div>
    </section>

    <section class="grid" id="results"></section>

    <p class="footer">Tip: 출력영역에서 <span class="kbd">Ctrl/Cmd</span> + <span class="kbd">F</span> 로 추가 검색이 가능합니다.</p>
  </main>

  <script>
    // ===== pdf.js 로더 & 워커 경로 보장 =====
    // pdf.js가 로드될 때까지 대기 후 workerSrc를 설정합니다.
    async function waitForPdfjs(){
      if (window.pdfjsLib && window.pdfjsLib.getDocument) return true;
      await new Promise((resolve, reject)=>{
        let t=0, max=100; // 최대 10초 대기
        const iv = setInterval(()=>{
          if (window.pdfjsLib && window.pdfjsLib.getDocument){ clearInterval(iv); resolve(); }
          else if (++t>max){ clearInterval(iv); reject(new Error('pdf.js 로딩 실패 — 네트워크 상태를 확인하세요.')); }
        }, 100);
      });
      return true;
    }
    async function ensureWorker(){
      await waitForPdfjs();
      try {
        if (!window.pdfjsLib.GlobalWorkerOptions.workerSrc) {
          window.pdfjsLib.GlobalWorkerOptions.workerSrc = `${PDFJS_CDN_BASE}/pdf.worker.min.js`;
        }
      } catch (e) {
        console.warn('pdf.js worker 설정 실패', e);
      }
    }

    // ===== 유틸 =====
    const $ = sel => document.querySelector(sel);
    const $$ = sel => Array.from(document.querySelectorAll(sel));
    const escapeHTML = (s='') => s.replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[m]));
    const formatBytes = (b=0) => {
      if (!b) return '0 B';
      const u = ['B','KB','MB','GB'];
      const i = Math.min(u.length-1, Math.floor(Math.log(b)/Math.log(1024)));
      return (b/Math.pow(1024,i)).toFixed(2)+' '+u[i];
    };

    // 텍스트 하이라이트(간단 버전)
    function highlightAll(container, query){
      if (!container) return;
      const text = container.dataset.rawText || '';
      if (!query) { container.innerHTML = escapeHTML(text); return; }
      const pattern = new RegExp(query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
      const html = escapeHTML(text).replace(pattern, (m)=>`<mark>${m}</mark>`);
      container.innerHTML = html;
    }

    // 텍스트 파일 다운로드
    function downloadText(filename, text){
      const blob = new Blob([text], {type:'text/plain;charset=utf-8'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = filename; document.body.appendChild(a); a.click();
      a.remove(); URL.revokeObjectURL(url);
    }

    // ===== 메인 로직 =====
    const dropzone = $('#dropzone');
    const input = $('#fileInput');
    const results = $('#results');
    const btnClear = $('#btnClear');

    // 드래그 앤 드롭 이벤트
    ['dragenter','dragover'].forEach(ev => dropzone.addEventListener(ev, (e)=>{
      e.preventDefault(); e.stopPropagation(); dropzone.classList.add('dragover');
    }));
    ['dragleave','drop'].forEach(ev => dropzone.addEventListener(ev, (e)=>{
      e.preventDefault(); e.stopPropagation(); dropzone.classList.remove('dragover');
    }));
    dropzone.addEventListener('drop', (e)=>{
      const files = Array.from(e.dataTransfer.files || []).filter(f => /pdf$/i.test(f.type) || /\.pdf$/i.test(f.name));
      if (files.length) handleFiles(files);
    });

    input.addEventListener('change', (e)=>{
      const files = Array.from(e.target.files || []);
      if (files.length) handleFiles(files);
      input.value = '';
    });

    btnClear.addEventListener('click', ()=>{ results.innerHTML=''; });

    async function handleFiles(files){
      await ensureWorker();
      for (const file of files) {
        await renderFileCard(file);
      }
    }

    // 파일 카드 생성 및 처리
    async function renderFileCard(file){
      await ensureWorker();
      const id = 'f_'+Math.random().toString(36).slice(2,8);
      const card = document.createElement('article');
      card.className = 'card';
      card.innerHTML = `
        <div class="hd">
          <div>
            <strong>${escapeHTML(file.name)}</strong>
            <div class="meta">${formatBytes(file.size)}</div>
          </div>
          <div class="u-flex">
            <button class="btn small ghost" data-act="copy" data-id="${id}">복사</button>
            <button class="btn small" data-act="download" data-id="${id}">TXT 저장</button>
          </div>
        </div>
        <div class="bd">
          <div class="row">
            <div class="progress"><span id="${id}_bar" style="width:0%"></span></div>
            <div class="meta" id="${id}_meta">대기중…</div>
          </div>
          <div class="row" style="margin-top:10px">
            <div class="searchbar">
              <input type="search" placeholder="텍스트 내 검색어 입력" id="${id}_q" aria-label="검색어" />
              <button class="btn small ghost" data-act="search" data-id="${id}">검색</button>
              <span class="tag" id="${id}_pages">페이지: -</span>
            </div>
          </div>
          <div class="row" style="margin-top:10px">
            <textarea class="output" id="${id}_out" placeholder="텍스트 출력 영역" readonly></textarea>
          </div>
          <div class="row" style="margin-top:10px">
            <details id="${id}_perpage">
              <summary>페이지별 텍스트 보기</summary>
              <div id="${id}_pagesWrap" style="padding:10px"></div>
            </details>
          </div>
        </div>`;
      results.prepend(card);

      // 처리 시작
      const metaEl = $('#'+id+'_meta');
      const barEl = $('#'+id+'_bar');
      const outEl = $('#'+id+'_out');
      const pagesBadge = $('#'+id+'_pages');
      const pagesWrap = $('#'+id+'_pagesWrap');

      try {
        metaEl.textContent = '파일 읽는 중…';
        const buf = await file.arrayBuffer();
        metaEl.textContent = 'PDF 파싱 중…';
        const doc = await window.pdfjsLib.getDocument({ data: buf }).promise;

        const total = doc.numPages;
        pagesBadge.textContent = `페이지: ${total}`;

        let all = '';
        for (let p = 1; p <= total; p++) {
          const page = await doc.getPage(p);
          const content = await page.getTextContent();
          // PDF의 텍스트 아이템을 단순 결합 (복잡한 레이아웃은 줄바꿈이 완벽하지 않을 수 있음)
          const text = (content.items || []).map(it => it.str).join(' ').replace(/\s+/g, ' ').trim();
          all += (p>1?'\n':'') + text;

          // 페이지별 UI 추가
          const d = document.createElement('details');
          d.innerHTML = `<summary>페이지 ${p}</summary><div class="pageText" id="${id}_p${p}"></div>`;
          pagesWrap.appendChild(d);
          const pageEl = $('#'+id+'_p'+p);
          pageEl.textContent = text || '[이 페이지에서 추출된 텍스트가 없습니다]';

          metaEl.textContent = `페이지 ${p}/${total} 처리 중…`;
          barEl.style.width = Math.round((p/total)*100)+'%';
        }

        // 출력 영역 채우기 및 하이라이트용 원본 저장
        outEl.value = all || '[추출된 텍스트가 없습니다]';
        // 검색 하이라이트를 위해 별도 div를 쓰는 대신 textarea의 원본을 dataset에 보관하고,
        // 화면 하이라이트가 필요할 때만 변환된 미러 div를 잠시 사용합니다.
        // 간단화를 위해 textarea 아래 보조 출력 div를 동적으로 생성합니다.
        const mirror = document.createElement('div');
        mirror.className = 'output';
        mirror.style.display = 'none';
        mirror.style.minHeight = outEl.style.minHeight;
        mirror.style.border = outEl.style.border;
        mirror.style.background = '#fff';
        mirror.style.whiteSpace = 'pre-wrap';
        mirror.style.borderRadius = outEl.style.borderRadius;
        mirror.style.padding = outEl.style.padding;
        outEl.insertAdjacentElement('afterend', mirror);
        mirror.dataset.rawText = all;
        mirror.textContent = all;

        // 검색 버튼 로직
        card.querySelector(`[data-act="search"][data-id="${id}"]`).addEventListener('click', ()=>{
          const q = (document.getElementById(id+"_q").value || '').trim();
          if (!q) { mirror.style.display='none'; outEl.style.display='block'; return; }
          highlightAll(mirror, q);
          outEl.style.display='none';
          mirror.style.display='block';
        });

        // 복사/다운로드 버튼
        card.querySelector(`[data-act="copy"][data-id="${id}"]`).addEventListener('click', async ()=>{
          try { await navigator.clipboard.writeText(all); toast(card, '클립보드로 복사했어요', 'ok'); }
          catch(e){ toast(card, '복사 실패: 권한을 확인하세요', 'err'); }
        });
        card.querySelector(`[data-act="download"][data-id="${id}"]`).addEventListener('click', ()=>{
          const base = file.name.replace(/\.pdf$/i,'') || 'extracted';
          downloadText(`${base}.txt`, all || '');
        });

        metaEl.innerHTML = `<span class="tag" style="border-color:#bbf7d0;color:${getComputedStyle(document.documentElement).getPropertyValue('--success')}">완료</span> 추출이 끝났습니다.`;
        barEl.style.width = '100%';

        // 스캔본(이미지) 안내 힌트
        if (!all || all.replace(/\s/g,'').length < 10) {
          const warn = document.createElement('div');
          warn.className = 'hint';
          warn.style.marginTop = '8px';
          warn.style.color = '#9a3412';
          warn.innerHTML = '※ 텍스트가 거의 없네요. 스캔본(이미지) PDF일 수 있어요. 이런 경우 <strong>OCR(Tesseract.js)</strong> 연동이 필요합니다.';
          pagesWrap.parentElement.insertAdjacentElement('beforebegin', warn);
        }

      } catch (err) {
        console.error(err);
        metaEl.innerHTML = `<span class="tag" style="color:${getComputedStyle(document.documentElement).getPropertyValue('--danger')}">에러</span> ${escapeHTML(err.message || err)}`;
        barEl.style.background = 'var(--danger)';
      }
    }

    // 간단 토스트
    function toast(root, msg, type='ok'){
      const el = document.createElement('div');
      el.textContent = msg;
      el.style.position = 'fixed';
      el.style.right = '16px';
      el.style.bottom = '16px';
      el.style.padding = '10px 12px';
      el.style.borderRadius = '10px';
      el.style.border = '1px solid var(--border)';
      el.style.background = type==='ok' ? '#ecfdf5' : '#fff1f2';
      el.style.color = type==='ok' ? '#065f46' : '#9f1239';
      el.style.boxShadow = '0 6px 20px rgba(0,0,0,.08)';
      document.body.appendChild(el);
      setTimeout(()=> el.remove(), 1800);
    }
  </script>
</body>
</html>
